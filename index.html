<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üî±</text></svg>" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Tritan - AI-Native Workflow Engine" />
  <title>Tritan üî± - AI Workflow Engine</title>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg-primary: #0a0a0f;
      --bg-secondary: #12121a;
      --bg-tertiary: #1a1a25;
      --accent-primary: #6366f1;
      --accent-secondary: #22d3ee;
      --accent-success: #22c55e;
      --accent-warning: #f59e0b;
      --accent-error: #ef4444;
      --text-primary: #ffffff;
      --text-secondary: #a1a1aa;
      --text-muted: #71717a;
      --border-color: rgba(255, 255, 255, 0.1);
      --glass-bg: rgba(255, 255, 255, 0.05);
      --glass-blur: blur(12px);
      --node-trigger: #22c55e;
      --node-action: #6366f1;
      --node-condition: #f59e0b;
      --node-llm: #ec4899;
      --radius-md: 8px;
      --radius-lg: 12px;
    }

    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

    html,
    body,
    #root {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(ellipse at top left, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(34, 211, 238, 0.15) 0%, transparent 50%),
        #0a0a0f;
      color: var(--text-primary);
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* TopBar */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 60px;
      padding: 0 20px;
      background: var(--glass-bg);
      border-bottom: 1px solid var(--border-color);
      backdrop-filter: var(--glass-blur);
    }

    .topbar-left,
    .topbar-actions {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-icon {
      font-size: 28px;
    }

    .logo-text {
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .workflow-name {
      background: transparent;
      border: 1px solid transparent;
      padding: 8px 12px;
      font-size: 14px;
      color: var(--text-primary);
      border-radius: var(--radius-md);
      width: 200px;
    }

    .workflow-name:hover {
      background: var(--glass-bg);
      border-color: var(--border-color);
    }

    .workflow-name:focus {
      outline: none;
      background: var(--bg-secondary);
      border-color: var(--accent-primary);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.15s ease;
      border: 1px solid var(--border-color);
      background: var(--glass-bg);
      color: var(--text-primary);
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-1px);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-primary), #4f46e5);
      border: none;
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
    }

    .btn-primary:hover {
      box-shadow: 0 0 30px rgba(99, 102, 241, 0.5);
    }

    .btn-guardian {
      background: rgba(239, 68, 68, 0.2);
      border-color: var(--accent-error);
    }

    /* Main Content */
    .main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      background: var(--glass-bg);
      border-right: 1px solid var(--border-color);
      backdrop-filter: var(--glass-blur);
      display: flex;
      flex-direction: column;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .sidebar-header h3 {
      font-size: 14px;
      font-weight: 600;
    }

    .sidebar-hint {
      font-size: 11px;
      color: var(--text-muted);
    }

    .node-list {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
      flex: 1;
    }

    .node-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      cursor: grab;
      transition: all 0.15s ease;
      border-left: 3px solid var(--node-color);
    }

    .node-item:hover {
      background: var(--bg-tertiary);
      transform: translateX(4px);
    }

    .node-icon {
      font-size: 18px;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
    }

    .node-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .node-label {
      font-size: 13px;
      font-weight: 500;
    }

    .node-desc {
      font-size: 10px;
      color: var(--text-muted);
    }

    .sidebar-tip {
      padding: 12px;
      font-size: 11px;
      color: var(--text-muted);
      border-top: 1px solid var(--border-color);
    }

    /* Canvas */
    .canvas {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    .canvas-viewport {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
      transition: transform 0.1s ease-out;
    }

    .canvas-grid {
      position: absolute;
      width: 5000px;
      height: 5000px;
      left: -2500px;
      top: -2500px;
      background-image: radial-gradient(circle, rgba(255, 255, 255, 0.08) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    /* Zoom Controls */
    .zoom-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 100;
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 18px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .zoom-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-primary);
    }

    .zoom-level {
      text-align: center;
      font-size: 11px;
      color: var(--text-muted);
      padding: 4px;
    }

    .canvas-empty {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
    }

    .canvas-empty-icon {
      font-size: 80px;
      opacity: 0.2;
      margin-bottom: 16px;
    }

    .canvas-empty h3 {
      font-size: 24px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .canvas-empty p {
      font-size: 14px;
      color: var(--text-muted);
    }

    /* Connections SVG */
    .connections-svg {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
    }

    .connection-line {
      fill: none;
      stroke: var(--accent-primary);
      stroke-width: 2;
      stroke-dasharray: 8 4;
      animation: dash 0.5s linear infinite;
    }

    .connection-line-temp {
      stroke: var(--accent-secondary);
      stroke-dasharray: 4 4;
      opacity: 0.7;
    }

    @keyframes dash {
      to {
        stroke-dashoffset: -12;
      }
    }

    /* Nodes */
    .dropped-nodes {
      position: absolute;
      inset: 0;
    }

    .dropped-node {
      position: absolute;
      min-width: 180px;
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: var(--radius-lg);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      cursor: move;
      border-top: 3px solid var(--node-color);
      user-select: none;
      transition: box-shadow 0.15s, border-color 0.15s;
    }

    .dropped-node:hover {
      border-color: var(--accent-primary);
    }

    .dropped-node.selected {
      border-color: var(--accent-primary);
      box-shadow: 0 0 30px rgba(99, 102, 241, 0.4);
    }

    .dropped-node.dragging {
      opacity: 0.9;
      cursor: grabbing;
      z-index: 1000;
    }

    .dropped-node-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.02);
      border-bottom: 1px solid var(--border-color);
    }

    .dropped-node-body {
      padding: 12px;
    }

    .dropped-node-field {
      margin-bottom: 8px;
    }

    .dropped-node-field label {
      display: block;
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .dropped-node-field select,
    .dropped-node-field input,
    .dropped-node-field textarea {
      width: 100%;
      padding: 6px 8px;
      font-size: 12px;
      color: var(--text-primary);
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }

    .dropped-node-field select:focus,
    .dropped-node-field input:focus,
    .dropped-node-field textarea:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    /* Connection Handles */
    .node-handle {
      position: absolute;
      width: 14px;
      height: 14px;
      background: var(--accent-primary);
      border: 2px solid var(--bg-primary);
      border-radius: 50%;
      cursor: crosshair;
      transition: transform 0.15s, box-shadow 0.15s;
      z-index: 10;
    }

    .node-handle:hover {
      transform: scale(1.3);
      box-shadow: 0 0 10px var(--accent-primary);
    }

    .node-handle-input {
      left: -7px;
      top: 50%;
      transform: translateY(-50%);
      background: var(--accent-secondary);
    }

    .node-handle-input:hover {
      transform: translateY(-50%) scale(1.3);
    }

    .node-handle-output {
      right: -7px;
      top: 50%;
      transform: translateY(-50%);
    }

    .node-handle-output:hover {
      transform: translateY(-50%) scale(1.3);
    }

    /* Guardian */
    .guardian {
      width: 280px;
      background: var(--glass-bg);
      border-left: 1px solid var(--border-color);
      backdrop-filter: var(--glass-blur);
      display: flex;
      flex-direction: column;
    }

    .guardian-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .guardian-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
    }

    .guardian-content {
      padding: 12px;
      flex: 1;
      overflow-y: auto;
    }

    .guardian-section {
      margin-bottom: 16px;
    }

    .guardian-section h4 {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .guardian-alert {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      margin-bottom: 8px;
      border-left: 3px solid var(--accent-warning);
    }

    .guardian-alert.error {
      border-left-color: var(--accent-error);
      background: rgba(239, 68, 68, 0.1);
    }

    .guardian-alert.success {
      border-left-color: var(--accent-success);
      background: rgba(34, 197, 94, 0.1);
    }

    .alert-icon {
      font-size: 14px;
    }

    .alert-message {
      font-size: 12px;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .guardian-empty {
      text-align: center;
      padding: 32px;
      color: var(--text-muted);
    }

    .guardian-empty span {
      font-size: 40px;
      display: block;
      margin-bottom: 8px;
      opacity: 0.4;
    }

    .guardian-stats {
      display: flex;
      gap: 8px;
    }

    .stat {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
    }

    .stat-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent-primary);
    }

    .stat-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .animate-in {
      animation: fadeIn 0.2s ease;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useCallback, useEffect } = React;

    const NODE_TYPES = {
      trigger: { label: 'Trigger', color: '#22c55e', icon: '‚ö°', desc: 'Start workflow' },
      action: { label: 'Action', color: '#6366f1', icon: '‚ñ∂Ô∏è', desc: 'Perform action' },
      condition: { label: 'Condition', color: '#f59e0b', icon: 'üîÄ', desc: 'Branch logic' },
      loop: { label: 'Loop', color: '#8b5cf6', icon: 'üîÑ', desc: 'Iterate items' },
      llm: { label: 'LLM', color: '#ec4899', icon: 'ü§ñ', desc: 'AI processing' },
      http: { label: 'HTTP', color: '#3b82f6', icon: 'üåê', desc: 'API requests' },
      code: { label: 'Code', color: '#14b8a6', icon: 'üíª', desc: 'Custom code' },
      transform: { label: 'Transform', color: '#f97316', icon: 'üîß', desc: 'Transform data' }
    };

    const LLM_PROVIDERS = {
      groq: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'],
      openrouter: ['anthropic/claude-3.5-sonnet', 'openai/gpt-4o', 'google/gemini-2.0-flash-exp:free'],
      cerebras: ['llama3.1-8b', 'llama3.1-70b'],
      gemini: ['gemini-2.0-flash-exp', 'gemini-1.5-pro']
    };

    function TopBar({ workflowName, setWorkflowName, onClear, onRun, onExport, onImport, guardianOpen, setGuardianOpen }) {
      return (
        <header className="topbar">
          <div className="topbar-left">
            <div className="logo">
              <span className="logo-icon">üî±</span>
              <span className="logo-text">Tritan</span>
            </div>
            <input
              type="text" className="workflow-name" value={workflowName}
              onChange={(e) => setWorkflowName(e.target.value)} placeholder="Workflow name..."
            />
          </div>
          <div className="topbar-actions">
            <button className="btn" onClick={onImport}>üìÇ Import</button>
            <button className="btn" onClick={onExport}>üíæ Export</button>
            <button className="btn" onClick={() => { localStorage.setItem('tritan-workflow', JSON.stringify({ workflowName })); alert('Saved!'); }}>‚úÖ Save</button>
            <button className="btn" onClick={onClear}>üóëÔ∏è Clear</button>
            <button className={`btn ${guardianOpen ? 'btn-guardian' : ''}`} onClick={() => setGuardianOpen(!guardianOpen)}>
              üõ°Ô∏è Guardian
            </button>
            <button className="btn btn-primary" onClick={onRun}>‚ñ∂Ô∏è Run</button>
          </div>
        </header>
      );
    }

    function Sidebar({ onDragStart }) {
      return (
        <aside className="sidebar">
          <div className="sidebar-header">
            <h3>üì¶ Nodes</h3>
            <span className="sidebar-hint">Drag to canvas</span>
          </div>
          <div className="node-list">
            {Object.entries(NODE_TYPES).map(([type, config]) => (
              <div key={type} className="node-item" style={{ '--node-color': config.color }}
                draggable onDragStart={(e) => onDragStart(e, type)}>
                <div className="node-icon">{config.icon}</div>
                <div className="node-info">
                  <span className="node-label">{config.label}</span>
                  <span className="node-desc">{config.desc}</span>
                </div>
              </div>
            ))}
          </div>
          <div className="sidebar-tip">
            üí° <b>Tip:</b> Connect nodes by dragging from output (right) to input (left) handles
          </div>
        </aside>
      );
    }

    function Canvas({ nodes, setNodes, connections, setConnections, selectedNode, setSelectedNode }) {
      const canvasRef = useRef(null);
      const [draggingNode, setDraggingNode] = useState(null);
      const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
      const [connectingFrom, setConnectingFrom] = useState(null);
      const [tempLine, setTempLine] = useState(null);
      const nodeRefs = useRef({});

      // Zoom and Pan state
      const [zoom, setZoom] = useState(1);
      const [pan, setPan] = useState({ x: 0, y: 0 });
      const [isPanning, setIsPanning] = useState(false);
      const [panStart, setPanStart] = useState({ x: 0, y: 0 });

      const handleWheel = useCallback((e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        setZoom(z => Math.min(2, Math.max(0.25, z + delta)));
      }, []);

      const zoomIn = () => setZoom(z => Math.min(2, z + 0.25));
      const zoomOut = () => setZoom(z => Math.max(0.25, z - 0.25));
      const resetZoom = () => { setZoom(1); setPan({ x: 0, y: 0 }); };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (canvas) {
          canvas.addEventListener('wheel', handleWheel, { passive: false });
          return () => canvas.removeEventListener('wheel', handleWheel);
        }
      }, [handleWheel]);

      const getNodeCenter = (nodeId, handleType) => {
        const node = nodes.find(n => n.id === nodeId);
        if (!node) return { x: 0, y: 0 };
        const el = nodeRefs.current[nodeId];
        const width = el ? el.offsetWidth : 180;
        const height = el ? el.offsetHeight : 80;
        return {
          x: node.x + (handleType === 'output' ? width : 0),
          y: node.y + height / 2
        };
      };

      const handleDrop = useCallback((e) => {
        e.preventDefault();
        const type = e.dataTransfer.getData('nodeType');
        if (!type) return;
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left - pan.x) / zoom - 90;
        const y = (e.clientY - rect.top - pan.y) / zoom - 40;
        const newNode = {
          id: `node-${Date.now()}`,
          type,
          x: Math.max(0, x),
          y: Math.max(0, y),
          data: {
            label: NODE_TYPES[type].label,
            provider: type === 'llm' ? 'groq' : null,
            model: type === 'llm' ? 'llama-3.3-70b-versatile' : null,
            prompt: '', config: {}
          }
        };
        setNodes(prev => [...prev, newNode]);
      }, [setNodes, zoom, pan]);

      const handleNodeMouseDown = (e, node) => {
        if (e.target.closest('.node-handle') || e.target.tagName === 'SELECT' ||
          e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        e.preventDefault();
        setSelectedNode(node.id);
        setDraggingNode(node.id);
        // Calculate offset in canvas coordinates (accounting for zoom)
        const rect = canvasRef.current.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - pan.x) / zoom;
        const mouseY = (e.clientY - rect.top - pan.y) / zoom;
        setDragOffset({ x: mouseX - node.x, y: mouseY - node.y });
      };

      const handleMouseMove = useCallback((e) => {
        const rect = canvasRef.current.getBoundingClientRect();

        // Panning with middle mouse or space+drag
        if (isPanning) {
          setPan({
            x: e.clientX - panStart.x,
            y: e.clientY - panStart.y
          });
          return;
        }

        if (draggingNode) {
          const x = (e.clientX - rect.left - pan.x) / zoom - dragOffset.x;
          const y = (e.clientY - rect.top - pan.y) / zoom - dragOffset.y;
          setNodes(prev => prev.map(n =>
            n.id === draggingNode ? { ...n, x: Math.max(0, x), y: Math.max(0, y) } : n
          ));
        }

        if (connectingFrom) {
          const start = getNodeCenter(connectingFrom.nodeId, 'output');
          const mouseX = (e.clientX - rect.left - pan.x) / zoom;
          const mouseY = (e.clientY - rect.top - pan.y) / zoom;
          setTempLine({ x1: start.x, y1: start.y, x2: mouseX, y2: mouseY });
        }
      }, [draggingNode, dragOffset, connectingFrom, setNodes, nodes, zoom, pan, isPanning, panStart]);

      const handleCanvasMouseDown = (e) => {
        // Middle mouse button or space for panning
        if (e.button === 1) {
          e.preventDefault();
          setIsPanning(true);
          setPanStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        }
      };

      const handleMouseUp = () => {
        setDraggingNode(null);
        setConnectingFrom(null);
        setTempLine(null);
        setIsPanning(false);
      };

      const handleOutputMouseDown = (e, nodeId) => {
        e.stopPropagation();
        setConnectingFrom({ nodeId });
      };

      const handleInputMouseUp = (e, targetNodeId) => {
        e.stopPropagation();
        if (connectingFrom && connectingFrom.nodeId !== targetNodeId) {
          const exists = connections.some(c => c.from === connectingFrom.nodeId && c.to === targetNodeId);
          if (!exists) {
            setConnections(prev => [...prev, {
              id: `conn-${Date.now()}`,
              from: connectingFrom.nodeId,
              to: targetNodeId
            }]);
          }
        }
        setConnectingFrom(null);
        setTempLine(null);
      };

      const updateNodeData = (nodeId, key, value) => {
        setNodes(prev => prev.map(n =>
          n.id === nodeId ? { ...n, data: { ...n.data, [key]: value } } : n
        ));
      };

      const deleteConnection = (connId) => {
        setConnections(prev => prev.filter(c => c.id !== connId));
      };

      return (
        <div className="canvas" ref={canvasRef}
          onDrop={handleDrop} onDragOver={(e) => e.preventDefault()}
          onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
          onMouseDown={handleCanvasMouseDown}
          onClick={() => setSelectedNode(null)}>

          <div className="canvas-viewport"
            style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})` }}>
            <div className="canvas-grid" />

            <svg className="connections-svg" style={{ position: 'absolute', width: '100%', height: '100%', overflow: 'visible' }}>
              {connections.map(conn => {
                const start = getNodeCenter(conn.from, 'output');
                const end = getNodeCenter(conn.to, 'input');
                const midX = (start.x + end.x) / 2;
                return (
                  <g key={conn.id} onClick={() => deleteConnection(conn.id)} style={{ cursor: 'pointer', pointerEvents: 'stroke' }}>
                    <path className="connection-line"
                      d={`M ${start.x} ${start.y} C ${midX} ${start.y}, ${midX} ${end.y}, ${end.x} ${end.y}`} />
                  </g>
                );
              })}
              {tempLine && (
                <path className="connection-line connection-line-temp"
                  d={`M ${tempLine.x1} ${tempLine.y1} L ${tempLine.x2} ${tempLine.y2}`} />
              )}
            </svg>

            <div className="dropped-nodes">
              {nodes.map(node => {
                const config = NODE_TYPES[node.type];
                return (
                  <div key={node.id}
                    ref={el => nodeRefs.current[node.id] = el}
                    className={`dropped-node animate-in ${selectedNode === node.id ? 'selected' : ''} ${draggingNode === node.id ? 'dragging' : ''}`}
                    style={{ left: node.x, top: node.y, '--node-color': config.color }}
                    onMouseDown={(e) => handleNodeMouseDown(e, node)}>

                    {node.type !== 'trigger' && (
                      <div className="node-handle node-handle-input"
                        onMouseUp={(e) => handleInputMouseUp(e, node.id)} />
                    )}

                    <div className="node-handle node-handle-output"
                      onMouseDown={(e) => handleOutputMouseDown(e, node.id)} />

                    <div className="dropped-node-header">
                      <span>{config.icon}</span>
                      <span className="node-label">{node.data.label}</span>
                    </div>

                    {node.type === 'llm' && (
                      <div className="dropped-node-body">
                        <div className="dropped-node-field">
                          <label>Provider</label>
                          <select value={node.data.provider || 'groq'}
                            onChange={(e) => updateNodeData(node.id, 'provider', e.target.value)}>
                            {Object.keys(LLM_PROVIDERS).map(p => (
                              <option key={p} value={p}>{p.charAt(0).toUpperCase() + p.slice(1)}</option>
                            ))}
                          </select>
                        </div>
                        <div className="dropped-node-field">
                          <label>Model</label>
                          <select value={node.data.model || ''}
                            onChange={(e) => updateNodeData(node.id, 'model', e.target.value)}>
                            {(LLM_PROVIDERS[node.data.provider] || []).map(m => (
                              <option key={m} value={m}>{m}</option>
                            ))}
                          </select>
                        </div>
                        <div className="dropped-node-field">
                          <label>Prompt</label>
                          <textarea value={node.data.prompt || ''}
                            onChange={(e) => updateNodeData(node.id, 'prompt', e.target.value)}
                            placeholder="Enter prompt..." rows={2} />
                        </div>
                      </div>
                    )}

                    {node.type === 'http' && (
                      <div className="dropped-node-body">
                        <div className="dropped-node-field">
                          <label>Method</label>
                          <select value={node.data.config?.method || 'GET'}
                            onChange={(e) => updateNodeData(node.id, 'config', { ...node.data.config, method: e.target.value })}>
                            <option value="GET">GET</option>
                            <option value="POST">POST</option>
                            <option value="PUT">PUT</option>
                            <option value="DELETE">DELETE</option>
                          </select>
                        </div>
                        <div className="dropped-node-field">
                          <label>URL</label>
                          <input type="text" value={node.data.config?.url || ''}
                            onChange={(e) => updateNodeData(node.id, 'config', { ...node.data.config, url: e.target.value })}
                            placeholder="https://api.example.com" />
                        </div>
                      </div>
                    )}

                    {node.type === 'condition' && (
                      <div className="dropped-node-body">
                        <div className="dropped-node-field">
                          <label>Condition</label>
                          <input type="text" value={node.data.config?.condition || ''}
                            onChange={(e) => updateNodeData(node.id, 'config', { ...node.data.config, condition: e.target.value })}
                            placeholder="value > 10" style={{ fontFamily: 'monospace' }} />
                        </div>
                      </div>
                    )}

                    {node.type === 'code' && (
                      <div className="dropped-node-body">
                        <div className="dropped-node-field">
                          <label>Code</label>
                          <textarea value={node.data.config?.code || ''}
                            onChange={(e) => updateNodeData(node.id, 'config', { ...node.data.config, code: e.target.value })}
                            placeholder="return data" rows={2} style={{ fontFamily: 'monospace' }} />
                        </div>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>

          {nodes.length === 0 && (
            <div className="canvas-empty">
              <div className="canvas-empty-icon">üî±</div>
              <h3>Start Building</h3>
              <p>Drag nodes from the left panel to create your workflow</p>
            </div>
          )}

          <div className="zoom-controls">
            <button className="zoom-btn" onClick={zoomIn} title="Zoom In">+</button>
            <div className="zoom-level">{Math.round(zoom * 100)}%</div>
            <button className="zoom-btn" onClick={zoomOut} title="Zoom Out">‚àí</button>
            <button className="zoom-btn" onClick={resetZoom} title="Reset" style={{ fontSize: 12 }}>‚ü≤</button>
          </div>
        </div>
      );
    }

    function Guardian({ nodes, connections }) {
      const errors = [];
      const warnings = [];

      if (nodes.length === 0) {
        errors.push('Add nodes to start building');
      } else {
        const hasTrigger = nodes.some(n => n.type === 'trigger');
        if (!hasTrigger) errors.push('Add a Trigger node to start');

        nodes.forEach(n => {
          if (n.type === 'llm' && !n.data.prompt) warnings.push(`LLM "${n.data.label}" has no prompt`);
          if (n.type === 'http' && !n.data.config?.url) warnings.push(`HTTP "${n.data.label}" has no URL`);
        });

        nodes.forEach(n => {
          if (n.type !== 'trigger') {
            const hasInput = connections.some(c => c.to === n.id);
            if (!hasInput) warnings.push(`"${n.data.label}" has no input connection`);
          }
        });
      }

      const isValid = errors.length === 0;

      return (
        <aside className="guardian">
          <div className="guardian-header">
            <div className="guardian-title"><span>üõ°Ô∏è</span><span>Guardian</span></div>
            <span style={{ fontSize: 12, color: isValid ? '#22c55e' : '#ef4444' }}>
              {isValid ? '‚úì Valid' : '‚úï Errors'}
            </span>
          </div>
          <div className="guardian-content">
            <div className="guardian-section">
              <h4>Validation</h4>
              {errors.map((err, i) => (
                <div key={i} className="guardian-alert error animate-in">
                  <span className="alert-icon">‚ùå</span>
                  <span className="alert-message">{err}</span>
                </div>
              ))}
              {warnings.map((warn, i) => (
                <div key={i} className="guardian-alert animate-in">
                  <span className="alert-icon">‚ö†Ô∏è</span>
                  <span className="alert-message">{warn}</span>
                </div>
              ))}
              {isValid && warnings.length === 0 && nodes.length > 0 && (
                <div className="guardian-alert success animate-in">
                  <span className="alert-icon">‚ú®</span>
                  <span className="alert-message">Workflow looks good!</span>
                </div>
              )}
              {nodes.length === 0 && (
                <div className="guardian-empty"><span>üî±</span><p>Add nodes to start</p></div>
              )}
            </div>
            <div className="guardian-section">
              <h4>Stats</h4>
              <div className="guardian-stats">
                <div className="stat"><span className="stat-value">{nodes.length}</span><span className="stat-label">Nodes</span></div>
                <div className="stat"><span className="stat-value">{connections.length}</span><span className="stat-label">Connections</span></div>
              </div>
            </div>
          </div>
        </aside>
      );
    }

    function App() {
      const [workflowName, setWorkflowName] = useState('New Workflow');
      const [nodes, setNodes] = useState([]);
      const [connections, setConnections] = useState([]);
      const [selectedNode, setSelectedNode] = useState(null);
      const [guardianOpen, setGuardianOpen] = useState(true);

      const handleDragStart = (e, type) => {
        e.dataTransfer.setData('nodeType', type);
        e.dataTransfer.effectAllowed = 'move';
      };

      const handleClear = () => { setNodes([]); setConnections([]); setSelectedNode(null); };

      const handleRun = () => {
        if (nodes.length === 0) return alert('Add nodes first!');
        if (!nodes.some(n => n.type === 'trigger')) return alert('Add a Trigger node!');
        alert('üöÄ Workflow ready!\n\nBackend needed for execution.');
      };

      const handleExport = () => {
        const data = JSON.stringify({ name: workflowName, nodes, connections }, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url;
        a.download = `${workflowName.replace(/\s+/g, '_')}.json`; a.click();
      };

      const handleImport = () => {
        const input = document.createElement('input');
        input.type = 'file'; input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const data = JSON.parse(e.target.result);
                setWorkflowName(data.name || 'Imported');
                setNodes(data.nodes || []);
                setConnections(data.connections || []);
              } catch { alert('Invalid file'); }
            };
            reader.readAsText(file);
          }
        };
        input.click();
      };

      return (
        <div className="app">
          <TopBar workflowName={workflowName} setWorkflowName={setWorkflowName}
            onClear={handleClear} onRun={handleRun} onExport={handleExport} onImport={handleImport}
            guardianOpen={guardianOpen} setGuardianOpen={setGuardianOpen} />
          <div className="main-content">
            <Sidebar onDragStart={handleDragStart} />
            <Canvas nodes={nodes} setNodes={setNodes} connections={connections} setConnections={setConnections}
              selectedNode={selectedNode} setSelectedNode={setSelectedNode} />
            {guardianOpen && <Guardian nodes={nodes} connections={connections} />}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>

</html>