<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üî±</text></svg>" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Tritan - AI-Native Workflow Engine" />
  <title>Tritan üî± - AI Workflow Engine</title>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
    rel="stylesheet">

  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      /* Premium Dark Theme */
      --bg-base: #09090b;
      --bg-elevated: #18181b;
      --bg-muted: #27272a;
      --bg-subtle: #3f3f46;

      /* Accent Colors */
      --accent: #a855f7;
      --accent-hover: #c084fc;
      --accent-muted: rgba(168, 85, 247, 0.15);
      --cyan: #06b6d4;
      --cyan-muted: rgba(6, 182, 212, 0.15);

      /* Status Colors */
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --info: #3b82f6;

      /* Node Colors */
      --node-trigger: #10b981;
      --node-action: #6366f1;
      --node-condition: #f59e0b;
      --node-loop: #8b5cf6;
      --node-llm: #ec4899;
      --node-http: #3b82f6;
      --node-code: #14b8a6;
      --node-transform: #f97316;

      /* Text */
      --text: #fafafa;
      --text-muted: #a1a1aa;
      --text-subtle: #71717a;

      /* Borders */
      --border: rgba(255, 255, 255, 0.08);
      --border-hover: rgba(255, 255, 255, 0.15);

      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
      --shadow-glow: 0 0 40px rgba(168, 85, 247, 0.2);

      /* Radius */
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 16px;
      --radius-full: 9999px;
    }

    html,
    body,
    #root {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-base);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
    }

    /* ========== TOP BAR ========== */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 56px;
      padding: 0 16px;
      background: var(--bg-elevated);
      border-bottom: 1px solid var(--border);
      gap: 16px;
    }

    .topbar-section {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      padding-right: 16px;
      border-right: 1px solid var(--border);
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--accent), var(--cyan));
      border-radius: var(--radius-md);
      font-size: 18px;
    }

    .logo-text {
      font-size: 18px;
      font-weight: 700;
      letter-spacing: -0.5px;
    }

    .workflow-input {
      background: var(--bg-muted);
      border: 1px solid var(--border);
      padding: 8px 14px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      border-radius: var(--radius-md);
      width: 180px;
      transition: all 0.2s;
    }

    .workflow-input:hover {
      border-color: var(--border-hover);
    }

    .workflow-input:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--bg-elevated);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      height: 34px;
      padding: 0 14px;
      font-size: 13px;
      font-weight: 500;
      font-family: inherit;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all 0.15s;
      border: 1px solid var(--border);
      background: var(--bg-muted);
      color: var(--text);
    }

    .btn:hover {
      background: var(--bg-subtle);
      border-color: var(--border-hover);
    }

    .btn-icon {
      width: 34px;
      padding: 0;
    }

    .btn-accent {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
      font-weight: 600;
    }

    .btn-accent:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
    }

    .btn-ghost {
      background: transparent;
      border-color: transparent;
    }

    .btn-ghost:hover {
      background: var(--bg-muted);
    }

    .divider {
      width: 1px;
      height: 24px;
      background: var(--border);
    }

    /* ========== MAIN LAYOUT ========== */
    .main {
      display: grid;
      grid-template-columns: 220px 1fr 300px;
      overflow: hidden;
    }

    /* ========== SIDEBAR ========== */
    .sidebar {
      background: var(--bg-elevated);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .sidebar-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-subtle);
    }

    .node-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .node-category {
      margin-bottom: 8px;
    }

    .node-category-title {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-subtle);
      padding: 8px;
    }

    .node-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: var(--radius-md);
      cursor: grab;
      transition: all 0.15s;
      margin-bottom: 2px;
    }

    .node-item:hover {
      background: var(--bg-muted);
    }

    .node-item:active {
      cursor: grabbing;
    }

    .node-icon {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-sm);
      font-size: 14px;
      background: var(--node-color);
      opacity: 0.9;
    }

    .node-meta {
      flex: 1;
      min-width: 0;
    }

    .node-name {
      font-size: 13px;
      font-weight: 500;
    }

    .node-desc {
      font-size: 11px;
      color: var(--text-subtle);
      margin-top: 1px;
    }

    /* ========== CANVAS ========== */
    .canvas {
      position: relative;
      overflow: hidden;
      background: var(--bg-base);
    }

    .canvas.panning {
      cursor: grabbing;
    }

    .canvas-viewport {
      position: absolute;
      inset: 0;
      transform-origin: 0 0;
    }

    .canvas-grid {
      position: absolute;
      width: 10000px;
      height: 10000px;
      left: -5000px;
      top: -5000px;
      background-image:
        linear-gradient(var(--border) 1px, transparent 1px),
        linear-gradient(90deg, var(--border) 1px, transparent 1px);
      background-size: 24px 24px;
      opacity: 0.4;
    }

    .canvas-origin {
      position: absolute;
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
      left: -4px;
      top: -4px;
      box-shadow: 0 0 12px var(--accent);
    }

    /* Connections */
    .connections-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
    }

    .connection {
      fill: none;
      stroke: var(--accent);
      stroke-width: 2;
      opacity: 0.6;
      transition: opacity 0.15s;
    }

    .connection:hover {
      opacity: 1;
      stroke-width: 3;
    }

    .connection-temp {
      stroke: var(--cyan);
      stroke-dasharray: 6 4;
      opacity: 0.8;
    }

    /* Nodes Layer */
    .nodes-layer {
      position: absolute;
      inset: 0;
    }

    .workflow-node {
      position: absolute;
      min-width: 200px;
      max-width: 280px;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      cursor: move;
      transition: box-shadow 0.15s, border-color 0.15s;
    }

    .workflow-node::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--node-color);
      border-radius: var(--radius-lg) var(--radius-lg) 0 0;
    }

    .workflow-node:hover {
      border-color: var(--border-hover);
    }

    .workflow-node.selected {
      border-color: var(--accent);
      box-shadow: var(--shadow-lg), 0 0 0 2px var(--accent-muted);
    }

    .workflow-node.dragging {
      opacity: 0.85;
      z-index: 1000;
    }

    .node-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
    }

    .node-header-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--node-color);
      border-radius: var(--radius-sm);
      font-size: 12px;
    }

    .node-header-title {
      font-size: 13px;
      font-weight: 600;
    }

    .node-content {
      padding: 12px 14px;
    }

    .node-field {
      margin-bottom: 10px;
    }

    .node-field:last-child {
      margin-bottom: 0;
    }

    .node-field-label {
      display: block;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      color: var(--text-subtle);
      margin-bottom: 6px;
    }

    .node-field-input,
    .node-field-select,
    .node-field-textarea {
      width: 100%;
      padding: 8px 10px;
      font-size: 12px;
      font-family: inherit;
      color: var(--text);
      background: var(--bg-muted);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      transition: all 0.15s;
    }

    .node-field-input:focus,
    .node-field-select:focus,
    .node-field-textarea:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--bg-base);
    }

    .node-field-textarea {
      resize: vertical;
      min-height: 60px;
    }

    .node-field-code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
    }

    /* Node Handles */
    .node-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--bg-subtle);
      border: 2px solid var(--text-subtle);
      border-radius: 50%;
      cursor: crosshair;
      transition: all 0.15s;
      z-index: 10;
    }

    .node-handle:hover {
      transform: scale(1.4);
      background: var(--accent);
      border-color: var(--accent);
      box-shadow: 0 0 8px var(--accent);
    }

    .node-handle-in {
      left: -6px;
      top: 50%;
      transform: translateY(-50%);
      border-color: var(--cyan);
    }

    .node-handle-in:hover {
      transform: translateY(-50%) scale(1.4);
      background: var(--cyan);
    }

    .node-handle-out {
      right: -6px;
      top: 50%;
      transform: translateY(-50%);
      border-color: var(--accent);
    }

    .node-handle-out:hover {
      transform: translateY(-50%) scale(1.4);
      background: var(--accent);
    }

    /* Canvas Controls */
    .canvas-controls {
      position: absolute;
      bottom: 16px;
      left: 16px;
      display: flex;
      gap: 4px;
      background: var(--bg-elevated);
      padding: 6px;
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-md);
    }

    .zoom-btn {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .zoom-btn:hover {
      background: var(--bg-muted);
      color: var(--text);
    }

    .zoom-display {
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      min-width: 48px;
      justify-content: center;
    }

    .canvas-empty {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
    }

    .canvas-empty-icon {
      font-size: 56px;
      margin-bottom: 16px;
      opacity: 0.3;
    }

    .canvas-empty-title {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .canvas-empty-desc {
      font-size: 14px;
      color: var(--text-subtle);
    }

    /* ========== GUARDIAN PANEL ========== */
    .guardian {
      background: var(--bg-elevated);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .guardian-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      border-bottom: 1px solid var(--border);
    }

    .guardian-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 600;
    }

    .guardian-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 600;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
    }

    .status-dot.error {
      background: var(--error);
    }

    .guardian-body {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .guardian-section {
      margin-bottom: 20px;
    }

    .guardian-section:last-child {
      margin-bottom: 0;
    }

    .guardian-section-title {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-subtle);
      margin-bottom: 10px;
    }

    .alert {
      display: flex;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-muted);
      border-radius: var(--radius-md);
      margin-bottom: 8px;
      border-left: 3px solid var(--warning);
    }

    .alert.error {
      border-color: var(--error);
      background: rgba(239, 68, 68, 0.08);
    }

    .alert.success {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.08);
    }

    .alert-icon {
      font-size: 14px;
      flex-shrink: 0;
    }

    .alert-text {
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .guardian-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
    }

    .guardian-empty-icon {
      font-size: 32px;
      margin-bottom: 12px;
      opacity: 0.4;
    }

    .guardian-empty-text {
      font-size: 13px;
      color: var(--text-subtle);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .stat-card {
      background: var(--bg-muted);
      border-radius: var(--radius-md);
      padding: 14px;
      text-align: center;
    }

    .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--accent);
      line-height: 1;
    }

    .stat-label {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      color: var(--text-subtle);
      margin-top: 6px;
    }

    /* ========== ANIMATIONS ========== */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.96);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .animate-in {
      animation: fadeIn 0.15s ease-out;
    }

    /* ========== SCROLLBAR ========== */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-subtle);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-subtle);
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useCallback, useEffect } = React;

    const NODE_TYPES = {
      trigger: { label: 'Trigger', color: 'var(--node-trigger)', icon: '‚ö°', desc: 'Start point', category: 'flow' },
      action: { label: 'Action', color: 'var(--node-action)', icon: '‚ñ∂', desc: 'Execute task', category: 'flow' },
      condition: { label: 'Condition', color: 'var(--node-condition)', icon: '‚óá', desc: 'Branch logic', category: 'flow' },
      loop: { label: 'Loop', color: 'var(--node-loop)', icon: '‚Üª', desc: 'Iterate items', category: 'flow' },
      llm: { label: 'LLM', color: 'var(--node-llm)', icon: '‚ú¶', desc: 'AI inference', category: 'ai' },
      http: { label: 'HTTP', color: 'var(--node-http)', icon: '‚áÑ', desc: 'API call', category: 'data' },
      code: { label: 'Code', color: 'var(--node-code)', icon: '{ }', desc: 'Custom script', category: 'data' },
      transform: { label: 'Transform', color: 'var(--node-transform)', icon: '‚ü∑', desc: 'Map data', category: 'data' }
    };

    const LLM_PROVIDERS = {
      groq: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'],
      openrouter: ['anthropic/claude-3.5-sonnet', 'openai/gpt-4o', 'google/gemini-2.0-flash-exp:free'],
      cerebras: ['llama3.1-8b', 'llama3.1-70b'],
      gemini: ['gemini-2.0-flash-exp', 'gemini-1.5-pro']
    };

    const CATEGORIES = { flow: 'Control Flow', ai: 'AI & ML', data: 'Data' };

    // ========== TOPBAR ==========
    function TopBar({ name, setName, onClear, onRun, onExport, onImport }) {
      return (
        <header className="topbar">
          <div className="topbar-section">
            <div className="logo">
              <div className="logo-icon">üî±</div>
              <span className="logo-text">Tritan</span>
            </div>
            <input className="workflow-input" value={name} onChange={e => setName(e.target.value)} placeholder="Untitled workflow" />
          </div>
          <div className="topbar-section">
            <button className="btn btn-ghost btn-icon" onClick={onImport} title="Import">üìÇ</button>
            <button className="btn btn-ghost btn-icon" onClick={onExport} title="Export">üíæ</button>
            <button className="btn btn-ghost btn-icon" onClick={onClear} title="Clear">üóë</button>
            <div className="divider" />
            <button className="btn btn-accent" onClick={onRun}>‚ñ∂ Run</button>
          </div>
        </header>
      );
    }

    // ========== SIDEBAR ==========
    function Sidebar({ onDragStart }) {
      const grouped = Object.entries(NODE_TYPES).reduce((acc, [id, node]) => {
        if (!acc[node.category]) acc[node.category] = [];
        acc[node.category].push({ id, ...node });
        return acc;
      }, {});

      return (
        <aside className="sidebar">
          <div className="sidebar-header">
            <span className="sidebar-title">Nodes</span>
          </div>
          <div className="node-list">
            {Object.entries(grouped).map(([cat, nodes]) => (
              <div key={cat} className="node-category">
                <div className="node-category-title">{CATEGORIES[cat]}</div>
                {nodes.map(node => (
                  <div key={node.id} className="node-item" style={{ '--node-color': node.color }}
                    draggable onDragStart={e => onDragStart(e, node.id)}>
                    <div className="node-icon">{node.icon}</div>
                    <div className="node-meta">
                      <div className="node-name">{node.label}</div>
                      <div className="node-desc">{node.desc}</div>
                    </div>
                  </div>
                ))}
              </div>
            ))}
          </div>
        </aside>
      );
    }

    // ========== CANVAS ==========
    function Canvas({ nodes, setNodes, connections, setConnections, selectedNode, setSelectedNode }) {
      const canvasRef = useRef(null);
      const nodeRefs = useRef({});

      const [zoom, setZoom] = useState(1);
      const [pan, setPan] = useState({ x: 400, y: 200 });
      const [isPanning, setIsPanning] = useState(false);
      const [panStart, setPanStart] = useState({ x: 0, y: 0 });

      const [draggingNode, setDraggingNode] = useState(null);
      const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

      const [connectingFrom, setConnectingFrom] = useState(null);
      const [tempLine, setTempLine] = useState(null);

      // Zoom with wheel
      useEffect(() => {
        const el = canvasRef.current;
        const handleWheel = e => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.08 : 0.08;
          setZoom(z => Math.min(2, Math.max(0.25, z + delta)));
        };
        el?.addEventListener('wheel', handleWheel, { passive: false });
        return () => el?.removeEventListener('wheel', handleWheel);
      }, []);

      const screenToCanvas = (clientX, clientY) => {
        const rect = canvasRef.current.getBoundingClientRect();
        return {
          x: (clientX - rect.left - pan.x) / zoom,
          y: (clientY - rect.top - pan.y) / zoom
        };
      };

      const getNodeCenter = (nodeId, handle) => {
        const node = nodes.find(n => n.id === nodeId);
        if (!node) return { x: 0, y: 0 };
        const el = nodeRefs.current[nodeId];
        const w = el?.offsetWidth || 200;
        const h = el?.offsetHeight || 80;
        return { x: node.x + (handle === 'out' ? w : 0), y: node.y + h / 2 };
      };

      const handleDrop = e => {
        e.preventDefault();
        const type = e.dataTransfer.getData('nodeType');
        if (!type) return;
        const pos = screenToCanvas(e.clientX, e.clientY);
        setNodes(prev => [...prev, {
          id: `node-${Date.now()}`,
          type,
          x: pos.x - 100,
          y: pos.y - 40,
          data: {
            label: NODE_TYPES[type].label,
            provider: type === 'llm' ? 'groq' : null,
            model: type === 'llm' ? 'llama-3.3-70b-versatile' : null,
            prompt: '', config: {}
          }
        }]);
      };

      const handleCanvasMouseDown = e => {
        if (e.button === 1 || e.button === 2) { // Middle or Right click
          e.preventDefault();
          setIsPanning(true);
          setPanStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        }
      };

      const handleContextMenu = e => e.preventDefault();

      const handleNodeMouseDown = (e, node) => {
        if (e.target.closest('.node-handle') || ['SELECT', 'INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;
        e.preventDefault();
        e.stopPropagation();
        setSelectedNode(node.id);
        setDraggingNode(node.id);
        const pos = screenToCanvas(e.clientX, e.clientY);
        setDragOffset({ x: pos.x - node.x, y: pos.y - node.y });
      };

      const handleMouseMove = e => {
        if (isPanning) {
          setPan({ x: e.clientX - panStart.x, y: e.clientY - panStart.y });
          return;
        }

        if (draggingNode) {
          const pos = screenToCanvas(e.clientX, e.clientY);
          setNodes(prev => prev.map(n => n.id === draggingNode ? { ...n, x: pos.x - dragOffset.x, y: pos.y - dragOffset.y } : n));
        }

        if (connectingFrom) {
          const start = getNodeCenter(connectingFrom, 'out');
          const mouse = screenToCanvas(e.clientX, e.clientY);
          setTempLine({ ...start, x2: mouse.x, y2: mouse.y });
        }
      };

      const handleMouseUp = () => {
        setIsPanning(false);
        setDraggingNode(null);
        setConnectingFrom(null);
        setTempLine(null);
      };

      const handleOutputMouseDown = (e, nodeId) => {
        e.stopPropagation();
        setConnectingFrom(nodeId);
      };

      const handleInputMouseUp = (e, targetId) => {
        e.stopPropagation();
        if (connectingFrom && connectingFrom !== targetId) {
          const exists = connections.some(c => c.from === connectingFrom && c.to === targetId);
          if (!exists) setConnections(prev => [...prev, { id: `conn-${Date.now()}`, from: connectingFrom, to: targetId }]);
        }
        setConnectingFrom(null);
        setTempLine(null);
      };

      const deleteConnection = id => setConnections(prev => prev.filter(c => c.id !== id));

      const updateNodeData = (id, key, val) => {
        setNodes(prev => prev.map(n => n.id === id ? { ...n, data: { ...n.data, [key]: val } } : n));
      };

      return (
        <div className={`canvas ${isPanning ? 'panning' : ''}`} ref={canvasRef}
          onDrop={handleDrop} onDragOver={e => e.preventDefault()}
          onMouseDown={handleCanvasMouseDown} onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}
          onContextMenu={handleContextMenu}
          onClick={() => setSelectedNode(null)}>

          <div className="canvas-viewport" style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})` }}>
            <div className="canvas-grid" />
            <div className="canvas-origin" />

            <svg className="connections-layer" style={{ width: '100%', height: '100%', overflow: 'visible' }}>
              {connections.map(c => {
                const s = getNodeCenter(c.from, 'out');
                const e = getNodeCenter(c.to, 'in');
                const mx = (s.x + e.x) / 2;
                return (
                  <path key={c.id} className="connection" style={{ pointerEvents: 'stroke', cursor: 'pointer' }}
                    d={`M${s.x},${s.y} C${mx},${s.y} ${mx},${e.y} ${e.x},${e.y}`}
                    onClick={() => deleteConnection(c.id)} />
                );
              })}
              {tempLine && <path className="connection connection-temp" d={`M${tempLine.x},${tempLine.y} L${tempLine.x2},${tempLine.y2}`} />}
            </svg>

            <div className="nodes-layer">
              {nodes.map(node => {
                const cfg = NODE_TYPES[node.type];
                return (
                  <div key={node.id} ref={el => nodeRefs.current[node.id] = el}
                    className={`workflow-node animate-in ${selectedNode === node.id ? 'selected' : ''} ${draggingNode === node.id ? 'dragging' : ''}`}
                    style={{ left: node.x, top: node.y, '--node-color': cfg.color }}
                    onMouseDown={e => handleNodeMouseDown(e, node)}>

                    {node.type !== 'trigger' && <div className="node-handle node-handle-in" onMouseUp={e => handleInputMouseUp(e, node.id)} />}
                    <div className="node-handle node-handle-out" onMouseDown={e => handleOutputMouseDown(e, node.id)} />

                    <div className="node-header">
                      <div className="node-header-icon">{cfg.icon}</div>
                      <span className="node-header-title">{node.data.label}</span>
                    </div>

                    {node.type === 'llm' && (
                      <div className="node-content">
                        <div className="node-field">
                          <label className="node-field-label">Provider</label>
                          <select className="node-field-select" value={node.data.provider || 'groq'}
                            onChange={e => updateNodeData(node.id, 'provider', e.target.value)}>
                            {Object.keys(LLM_PROVIDERS).map(p => <option key={p} value={p}>{p}</option>)}
                          </select>
                        </div>
                        <div className="node-field">
                          <label className="node-field-label">Model</label>
                          <select className="node-field-select" value={node.data.model || ''} onChange={e => updateNodeData(node.id, 'model', e.target.value)}>
                            {(LLM_PROVIDERS[node.data.provider] || []).map(m => <option key={m} value={m}>{m}</option>)}
                          </select>
                        </div>
                        <div className="node-field">
                          <label className="node-field-label">Prompt</label>
                          <textarea className="node-field-textarea" value={node.data.prompt || ''} onChange={e => updateNodeData(node.id, 'prompt', e.target.value)} placeholder="Enter your prompt..." />
                        </div>
                      </div>
                    )}

                    {node.type === 'http' && (
                      <div className="node-content">
                        <div className="node-field">
                          <label className="node-field-label">Method</label>
                          <select className="node-field-select" value={node.data.config?.method || 'GET'}
                            onChange={e => updateNodeData(node.id, 'config', { ...node.data.config, method: e.target.value })}>
                            <option>GET</option><option>POST</option><option>PUT</option><option>DELETE</option>
                          </select>
                        </div>
                        <div className="node-field">
                          <label className="node-field-label">URL</label>
                          <input className="node-field-input" value={node.data.config?.url || ''} placeholder="https://api.example.com"
                            onChange={e => updateNodeData(node.id, 'config', { ...node.data.config, url: e.target.value })} />
                        </div>
                      </div>
                    )}

                    {node.type === 'condition' && (
                      <div className="node-content">
                        <div className="node-field">
                          <label className="node-field-label">Expression</label>
                          <input className="node-field-input node-field-code" value={node.data.config?.condition || ''} placeholder="value > 10"
                            onChange={e => updateNodeData(node.id, 'config', { ...node.data.config, condition: e.target.value })} />
                        </div>
                      </div>
                    )}

                    {node.type === 'code' && (
                      <div className="node-content">
                        <div className="node-field">
                          <label className="node-field-label">Script</label>
                          <textarea className="node-field-textarea node-field-code" value={node.data.config?.code || ''} placeholder="return data"
                            onChange={e => updateNodeData(node.id, 'config', { ...node.data.config, code: e.target.value })} />
                        </div>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>

          {nodes.length === 0 && (
            <div className="canvas-empty">
              <div className="canvas-empty-icon">üî±</div>
              <div className="canvas-empty-title">Build your workflow</div>
              <div className="canvas-empty-desc">Drag nodes from the sidebar to get started</div>
            </div>
          )}

          <div className="canvas-controls">
            <button className="zoom-btn" onClick={() => setZoom(z => Math.min(2, z + 0.25))}>+</button>
            <div className="zoom-display">{Math.round(zoom * 100)}%</div>
            <button className="zoom-btn" onClick={() => setZoom(z => Math.max(0.25, z - 0.25))}>‚àí</button>
            <button className="zoom-btn" onClick={() => { setZoom(1); setPan({ x: 400, y: 200 }); }}>‚åÇ</button>
          </div>
        </div>
      );
    }

    // ========== GUARDIAN ==========
    function Guardian({ nodes, connections }) {
      const errors = [];
      const warnings = [];

      if (nodes.length === 0) {
        errors.push('No nodes in workflow');
      } else {
        if (!nodes.some(n => n.type === 'trigger')) errors.push('Missing trigger node');
        nodes.forEach(n => {
          if (n.type === 'llm' && !n.data.prompt) warnings.push(`"${n.data.label}" needs a prompt`);
          if (n.type === 'http' && !n.data.config?.url) warnings.push(`"${n.data.label}" needs a URL`);
          if (n.type !== 'trigger' && !connections.some(c => c.to === n.id)) warnings.push(`"${n.data.label}" is disconnected`);
        });
      }

      const isValid = errors.length === 0;

      return (
        <aside className="guardian">
          <div className="guardian-header">
            <div className="guardian-title">
              <span>üõ°Ô∏è</span>
              <span>Guardian</span>
            </div>
            <div className="guardian-status">
              <div className={`status-dot ${isValid ? '' : 'error'}`} />
              <span>{isValid ? 'Valid' : 'Issues'}</span>
            </div>
          </div>
          <div className="guardian-body">
            <div className="guardian-section">
              <div className="guardian-section-title">Validation</div>
              {errors.map((e, i) => <div key={i} className="alert error animate-in"><span className="alert-icon">‚úï</span><span className="alert-text">{e}</span></div>)}
              {warnings.map((w, i) => <div key={i} className="alert animate-in"><span className="alert-icon">!</span><span className="alert-text">{w}</span></div>)}
              {isValid && warnings.length === 0 && nodes.length > 0 && (
                <div className="alert success animate-in"><span className="alert-icon">‚úì</span><span className="alert-text">Workflow is ready to run</span></div>
              )}
              {nodes.length === 0 && <div className="guardian-empty"><div className="guardian-empty-icon">üìã</div><div className="guardian-empty-text">Add nodes to validate</div></div>}
            </div>
            <div className="guardian-section">
              <div className="guardian-section-title">Statistics</div>
              <div className="stats-grid">
                <div className="stat-card"><div className="stat-value">{nodes.length}</div><div className="stat-label">Nodes</div></div>
                <div className="stat-card"><div className="stat-value">{connections.length}</div><div className="stat-label">Edges</div></div>
              </div>
            </div>
          </div>
        </aside>
      );
    }

    // ========== APP ==========
    function App() {
      const [name, setName] = useState('Untitled workflow');
      const [nodes, setNodes] = useState([]);
      const [connections, setConnections] = useState([]);
      const [selected, setSelected] = useState(null);

      const handleDragStart = (e, type) => {
        e.dataTransfer.setData('nodeType', type);
        e.dataTransfer.effectAllowed = 'move';
      };

      return (
        <div className="app">
          <TopBar name={name} setName={setName}
            onClear={() => { setNodes([]); setConnections([]); }}
            onRun={() => alert(nodes.length ? 'üöÄ Workflow ready! Connect to backend to execute.' : 'Add nodes first!')}
            onExport={() => {
              const blob = new Blob([JSON.stringify({ name, nodes, connections }, null, 2)], { type: 'application/json' });
              const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `${name.replace(/\s+/g, '_')}.json`; a.click();
            }}
            onImport={() => {
              const input = document.createElement('input'); input.type = 'file'; input.accept = '.json';
              input.onchange = e => {
                const f = e.target.files[0];
                if (f) {
                  const r = new FileReader();
                  r.onload = ev => { try { const d = JSON.parse(ev.target.result); setName(d.name || 'Imported'); setNodes(d.nodes || []); setConnections(d.connections || []); } catch { } };
                  r.readAsText(f);
                }
              };
              input.click();
            }}
          />
          <main className="main">
            <Sidebar onDragStart={handleDragStart} />
            <Canvas nodes={nodes} setNodes={setNodes} connections={connections} setConnections={setConnections} selectedNode={selected} setSelectedNode={setSelected} />
            <Guardian nodes={nodes} connections={connections} />
          </main>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>

</html>